import json
import sys
import rlcompleter, readline
readline.parse_and_bind('tab:complete')

def logdebug():
    import logging
    logging.basicConfig(level=logging.DEBUG)
    logging.getLogger(__name__).debug('debug logging enabled')

class CustomJSONEncoder(json.JSONEncoder):
    def default(self, obj):
        from datetime import datetime
        if isinstance(obj, datetime):
            return str(datetime)
        if hasattr(obj, '__json__'):
            return obj.__json__()
        return json.JSONEncoder.default(self, obj)

def jdump(d, **kwargs):
    return json.dumps(d, cls=CustomJSONEncoder, **kwargs)

def jwrite(d, path):
    import json
    if isinstance(d, str):
        d = json.loads(d)
    with open(path, 'w') as of:
        of.write(jdump(d, indent=2, sort_keys=True))

def jread(path):
    import json
    with open(path) as of:
        return json.loads(of.read())

def jprint(d):
    import json
    from collections.abc import KeysView, ValuesView

    if isinstance(d, str):
        d = json.loads(d)

    if isinstance(d, (KeysView, ValuesView, set)):
        d = list(d)

    print(jdump(d, indent=2, sort_keys=True))

def lprint(l):
    for idx, v in enumerate(l):
        print(f'{idx}: {v}')

def fcount(items, key):
    # count unique values for field in list of dicts
    from collections import defaultdict
    counter = defaultdict(int)
    for x in items:
        if key in x:
            counter[x[key]] += 1
        else:
            counter['MISSING_FIELD'] += 1
    jprint(counter)

def CamelCase2lower_case(s):
    chars = [ x for x in s ]
    newname = chars.pop(0).lower()
    for c in chars:
        if c.isupper():
            newname += '_'
            newname += c.lower()
        else:
            newname += c
    return newname

def stddev(nset):
    import math
    mean = sum(nset) / len(nset)
    vset = [ (x - mean)**2 for x in nset ]
    sd = math.sqrt(sum(vset) / (len(nset) - 1))
    print('sd     : %s' % sd)
    print('min sd : %s' % (mean - sd))
    print('max sd : %s' % (mean + sd))

def getsoup(url):
    import requests
    from bs4 import BeautifulSoup
    r = requests.get(url)
    return BeautifulSoup(r.text, 'html.parser')

def chromeopen(url):
    from subprocess import call
    call(['google-chrome-stable', '--incognito', url])

def iterfiles(d, maxdepth=None):
    import os

    depth = lambda x: x.strip('./').count('/') + 1 # get depth from root path

    for root, dirs, files in os.walk(d):
        for fname in files:
            if maxdepth and depth(root) > maxdepth:
                break
            yield os.path.join(root, fname)

def truncate(n, decimals=0):
    """ truncate float at given decimal (round down) """
    multiplier = 10 ** decimals
    return int(n * multiplier) / multiplier

def yaml2json(path):
    import yaml
    with open(path) as of:
        d = yaml.load(of.read())
    jprint(d)

if sys.argv[0].split('/')[-1] == '.pythonrc':
    if len(sys.argv) < 2:
        print('no function provided')
        sys.exit(1)
    fn = locals().get(sys.argv[1])
    if not fn:
        print(f'function not found: {sys.argv[1]}')
        sys.exit(1)
    fn(*sys.argv[2:])
