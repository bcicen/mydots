import os
import sys
import json
import rlcompleter, readline
readline.parse_and_bind('tab:complete')

__jlogfmt = {
  'asctime': '%(asctime)s',
  'thread': '%(threadName)-12.12s',
  'level': '%(levelname)-5.5s',
  'module': '%(module)s',
  'filename': '%(filename)s:%(lineno)d',
  'func': '%(funcName)s',
  'msg': '%(message)s'
}

if os.getenv('PYDEBUG'):
    import logging
    from tempfile import mkstemp

    path = mkstemp(prefix='pylog-')[1]
    logging.basicConfig(
        level=logging.DEBUG,
        format=json.dumps(__jlogfmt),
        handlers=[
            logging.FileHandler(path),
            logging.StreamHandler(sys.stdout)
        ])
    logging.getLogger("parso").setLevel(logging.ERROR)
    logging.getLogger(__name__).debug(f'debug logging enabled ({path})')


def logdebug():
    import logging
    logging.basicConfig(level=logging.DEBUG)
    logging.getLogger("parso").setLevel(logging.ERROR)
    logging.getLogger(__name__).debug('debug logging enabled')

class CustomJSONEncoder(json.JSONEncoder):
    def default(self, obj):
        from uuid import UUID
        from datetime import datetime
        if isinstance(obj, (UUID, datetime)):
            return str(obj)
        if hasattr(obj, '__json__'):
            return obj.__json__()
        return json.JSONEncoder.default(self, obj)

def jdump(d, **kwargs):
    return json.dumps(d, cls=CustomJSONEncoder, **kwargs)

def jwrite(d, path):
    import json
    if isinstance(d, str):
        d = json.loads(d)
    with open(path, 'w') as of:
        of.write(jdump(d, indent=2, sort_keys=True))

def jread(path):
    import json
    with open(path) as of:
        return json.loads(of.read())

def jprint(d):
    import json
    from collections.abc import KeysView, ValuesView

    if isinstance(d, str):
        d = json.loads(d)

    if isinstance(d, (KeysView, ValuesView, set)):
        d = list(d)

    print(jdump(d, indent=2, sort_keys=True))

def csvread(path):
    import csv
    idx, rows = 0, []
    with open(path) as of:
        try:
            for row in csv.reader(of, quotechar='"'):
                rows.append(row)
                idx+=1
        except Exception as ex:
            print('error at row {idx}')
            raise ex
    return rows

def lprint(l):
    for idx, v in enumerate(l):
        print(f'{idx}: {v}')

def fcount(items, key):
    # count unique values for field in list of dicts
    from collections import defaultdict
    counter = defaultdict(int)
    for x in items:
        if key in x:
            counter[x[key]] += 1
        else:
            counter['MISSING_FIELD'] += 1
    jprint(counter)

def CamelCase2lower_case(s):
    chars = [ x for x in s ]
    newname = chars.pop(0).lower()
    for c in chars:
        if c.isupper():
            newname += '_'
            newname += c.lower()
        else:
            newname += c
    return newname

def stddev(nset):
    import math
    mean = sum(nset) / len(nset)
    vset = [ (x - mean)**2 for x in nset ]
    sd = math.sqrt(sum(vset) / (len(nset) - 1))
    print('sd     : %s' % sd)
    print('min sd : %s' % (mean - sd))
    print('max sd : %s' % (mean + sd))

def getsoup(url):
    import requests
    from bs4 import BeautifulSoup
    r = requests.get(url)
    r.raise_for_status()
    return BeautifulSoup(r.text, 'html.parser')

def rdl(url, fname=None):
    import requests
    if not fname:
        fname = url.split('/')[-1]
    with requests.get(url, stream=True) as r:
        with open(fname, 'wb') as f:
            for chunk in r.iter_content(chunk_size=8192):
                f.write(chunk)
    return fname

def chromeopen(url):
    from subprocess import call
    call(['google-chrome-stable', '--incognito', url])

def iterfiles(d, maxdepth=None):
    import os

    depth = lambda x: x.strip('./').count('/') + 1 # get depth from root path

    for root, dirs, files in os.walk(d):
        for fname in files:
            if maxdepth and depth(root) > maxdepth:
                break
            yield os.path.join(root, fname)

def truncate(n, decimals=0):
    """ truncate float at given decimal (round down) """
    multiplier = 10 ** decimals
    return int(n * multiplier) / multiplier

def yread(path):
    import yaml
    with open(path) as of:
        d = list(yaml.load_all(of.read(), Loader=yaml.FullLoader))
    if len(d) == 1:
        return d[0]
    return d

def yaml2json(path):
    import yaml
    with open(path) as of:
        d = yaml.load_all(of.read(), Loader=yaml.FullLoader)
    jprint(list(d))

def pivot(items, key):
    from collections import defaultdict
    res = defaultdict(list)
    for x in items:
        res[x.get(key)].append(x)
    return res

def escape_ansi(line):
    import re
    ansi_escape = re.compile(r'(\x9B|\x1B\[)[0-?]*[ -/]*[@-~]')
    return ansi_escape.sub('', line)

# column-aligned output
def column(items, spacing=2):
    ret = []
    col_w = [ 1 for _ in items[0] ] # default minimum widths

    _len = lambda x: len(escape_ansi(x))

    def _maxw(line):
        for n, txt in enumerate(line):
            if _len(txt) > col_w[n]:
                col_w[n] = _len(txt)

    for line in items:
        _maxw(line)
    col_w = [ w+spacing for w in col_w ]

    for line in items:
        ret.append(''.join([ f'{txt: <{w}}' for w, txt in zip(col_w, line) ]))

    return '\n'.join(ret)

def md2html(path):
    from markdown2 import markdown, markdown_path
    extras = {
      'fenced-code-blocks': {'linenos': True},
      'highlightjs-lang': {}
    }

    # with open(path) as of:
        # text = of.read()
    markdown_path(path, extras)

class DictStats(dict):

    def add(self, *dicts):
        for d in dicts:
            self._add(d)

    def unique_kv_counts(self):
        rows = []
        for k,v in self.items():
            rows.append([ str(k), len(v) ])
        rows = [ [x[0], str(x[1])] for x in
                sorted(rows, key=lambda x: x[1], reverse=True) ]
        print(column(rows))

    def _add(self, d):
        from collections import defaultdict
        for k,v in d.items():
            if not isinstance(v, (str,int,float,bool)):
                continue
            if k not in self:
                self[k] = defaultdict(int)
            self[k][v] += 1


if sys.argv[0].split('/')[-1] == '.pythonrc':
    if len(sys.argv) < 2:
        print('no function provided')
        sys.exit(1)
    fn = locals().get(sys.argv[1])
    if not fn:
        print(f'function not found: {sys.argv[1]}')
        sys.exit(1)
    fn(*sys.argv[2:])
